/**
 * NOTE: This class is auto generated by the swagger code generator program (2.4.3-SNAPSHOT).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package pl.itger.polishAPI.io.swagger.api;

import pl.itger.polishAPI.io.swagger.model.AuthorizeRequest;
import pl.itger.polishAPI.io.swagger.model.AuthorizeResponse;
import pl.itger.polishAPI.io.swagger.model.EatCodeRequest;
import pl.itger.polishAPI.io.swagger.model.Error;
import pl.itger.polishAPI.io.swagger.model.RegisterRequest;
import pl.itger.polishAPI.io.swagger.model.RegisterResponse;
import pl.itger.polishAPI.io.swagger.model.TokenRequest;
import pl.itger.polishAPI.io.swagger.model.TokenResponse;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2019-12-26T17:08:40.154+01:00")

@Api(value = "As", description = "the As API")
public interface AsApi {

    AsApiDelegate getDelegate();

    @ApiOperation(value = "Żądanie kodu autoryzacji OAuth2 / Requests OAuth2 authorization code", nickname = "authorize", notes = "Żądanie kodu autoryzacji OAuth2 / Requests OAuth2 authorization code", response = AuthorizeResponse.class, tags={ "AS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Powodzenie / Success", response = AuthorizeResponse.class),
        @ApiResponse(code = 400, message = "Błędne żądanie / Bad request", response = Error.class),
        @ApiResponse(code = 405, message = "Metoda niedozwolona / Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Niedozwolone / Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Nieznany sposób żądania / Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Jednostka nieprzetwarzalna / Unprocessable entity", response = Error.class),
        @ApiResponse(code = 500, message = "Wewnętrzny błąd serwera / Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Nie zaimplementowano / Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Usługa niedostępna / Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v3_0.1/auth/v3_0.1/authorize",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<AuthorizeResponse> authorize(@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Preferowany język odpowiedzi / Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Osobny podpis JWS treści paylodu / Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Dane do zapytania o kod autoryzacyjny OAuth2 / Data for OAuth2 Authorization Code Request" ,required=true )  @Valid @RequestBody AuthorizeRequest authorizeRequest) {
        return getDelegate().authorize(acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, authorizeRequest);
    }


    @ApiOperation(value = "Żądanie wydania kodu autoryzacji OAuth2 na podstawie jednorazowego kodu autoryzacji wydanego przez narzędzie autoryzacji zewnętrznej / Requests OAuth2 authorization code based on One-time authorization code issued by External Authorization Tool", nickname = "authorizeExt", notes = "Żądanie wydania kodu autoryzacji OAuth2 na podstawie jednorazowego kodu autoryzacji wydanego przez narzędzie autoryzacji zewnętrznej. Kod autoryzacji zostanie dostarczony do TPP jako zapytanie zwrotne z ASPSP, jeśli uwierzytelnienie PSU zostanie potwierdzone przez EAT. Funkcja zwrotna musi zapewniać podobne powiadomienie również w przypadku nieudanego uwierzytelnienia lub jego rezygnacji. / Requests OAuth2 authorization code based One-time authorization code issued by External Authorization Tool. Authorization code will be delivered to TPP as callback request from ASPSP if PSU authentication is confirmed by EAT. Callback function must provide similar notification also in case of unsuccessful authentication or its abandonment.", tags={ "AS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "Weryfikacja TPP i EAT pomyślna / Successful TPP and EAT Code verification"),
        @ApiResponse(code = 400, message = "Błędne żądanie / Bad request", response = Error.class),
        @ApiResponse(code = 405, message = "Metoda niedozwolona / Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Niedozwolone / Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Nieznany sposób żądania / Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Jednostka nieprzetwarzalna / Unprocessable entity", response = Error.class),
        @ApiResponse(code = 500, message = "Wewnętrzny błąd serwera / Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Nie zaimplementowano / Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Usługa niedostępna / Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v3_0.1/auth/v3_0.1/authorizeExt",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<Void> authorizeExt(@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Preferowany język odpowiedzi / Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Osobny podpis JWS treści paylodu / Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Dane dla zapytania o kod autoryzacji OAuth2 rozszerzone dla uwierzytelniania opartego na EAT i odpowiedzi zwrotnej / Data for OAuth2 Authorization Code Request extended for EAT based authentication and callback response" ,required=true )  @Valid @RequestBody EatCodeRequest eatCodeRequest) {
        return getDelegate().authorizeExt(acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, eatCodeRequest);
    }


    @ApiOperation(value = "Żądanie rejestracji aplikacji klienckiej / Client application registration request", nickname = "register", notes = "Żądanie rejestracji aplikacji klienckiej / Client application registration request", response = RegisterResponse.class, tags={ "AS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 201, message = "Powodzenie / Success", response = RegisterResponse.class),
        @ApiResponse(code = 400, message = "Błędne żądanie / Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Nieautoryzowany dostęp / Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Zabronione / Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Metoda niedozwolona / Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Niedozwolone / Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Nieznany sposób żądania / Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Jednostka nieprzetwarzalna / Unprocessable entity", response = Error.class),
        @ApiResponse(code = 500, message = "Wewnętrzny błąd serwera / Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Nie zaimplementowano / Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Usługa niedostępna / Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v3_0.1/auth/v3_0.1/register",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<RegisterResponse> register(@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Preferowany język odpowiedzi / Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Dane żądania rejestracji aplikacji klienckiej / Client application registration request data" ,required=true )  @Valid @RequestBody RegisterRequest registerRequest) {
        return getDelegate().register(acceptEncoding, acceptLanguage, acceptCharset, X_REQUEST_ID, registerRequest);
    }


    @ApiOperation(value = "Żądanie wydania tokena dostępu OAuth2 / Requests OAuth2 access token value", nickname = "token", notes = "Żądanie wydania tokena dostępu OAuth2 / Requests OAuth2 access token value", response = TokenResponse.class, tags={ "AS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Powodzenie / Success", response = TokenResponse.class),
        @ApiResponse(code = 400, message = "Błędne żądanie / Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Nieautoryzowany dostęp / Unauthorized", response = Error.class),
        @ApiResponse(code = 405, message = "Metoda niedozwolona / Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Niedozwolone / Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Nieznany sposób żądania / Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Jednostka nieprzetwarzalna / Unprocessable entity", response = Error.class),
        @ApiResponse(code = 500, message = "Wewnętrzny błąd serwera / Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Nie zaimplementowano / Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Usługa niedostępna / Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v3_0.1/auth/v3_0.1/token",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<TokenResponse> token(@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Preferowany język odpowiedzi / Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Osobny podpis JWS treści paylodu / Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Dane żądania o wydanie tokena dostępu OAuth2 / Data for OAuth2 Access Token Request" ,required=true )  @Valid @RequestBody TokenRequest tokenRequest) {
        return getDelegate().token(acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, tokenRequest);
    }

}
