/**
 * NOTE: This class is auto generated by the swagger code generator program (2.4.3-SNAPSHOT).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package pl.itger.PolishAPI.io.swagger.api;

import pl.itger.PolishAPI.io.swagger.model.AccountInfoRequest;
import pl.itger.PolishAPI.io.swagger.model.AccountResponse;
import pl.itger.PolishAPI.io.swagger.model.AccountsRequest;
import pl.itger.PolishAPI.io.swagger.model.AccountsResponse;
import pl.itger.PolishAPI.io.swagger.model.DeleteConsentRequest;
import pl.itger.PolishAPI.io.swagger.model.Error;
import pl.itger.PolishAPI.io.swagger.model.HoldInfoResponse;
import pl.itger.PolishAPI.io.swagger.model.HoldRequest;
import pl.itger.PolishAPI.io.swagger.model.TransactionDetailRequest;
import pl.itger.PolishAPI.io.swagger.model.TransactionDetailResponse;
import pl.itger.PolishAPI.io.swagger.model.TransactionInfoRequest;
import pl.itger.PolishAPI.io.swagger.model.TransactionPendingInfoResponse;
import pl.itger.PolishAPI.io.swagger.model.TransactionRejectedInfoResponse;
import pl.itger.PolishAPI.io.swagger.model.TransactionsCancelledInfoResponse;
import pl.itger.PolishAPI.io.swagger.model.TransactionsDoneInfoResponse;
import pl.itger.PolishAPI.io.swagger.model.TransactionsScheduledInfoResponse;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2019-03-14T19:37:54.479+01:00")

@Api(value = "Ais", description = "the Ais API")
public interface AisApi {

    AisApiDelegate getDelegate();

    @ApiOperation(value = "Removes consent", nickname = "deleteConsent", notes = "Removes consent", tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "Success"),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/deleteConsent",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<Void> deleteConsent(@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for delete Consent Request" ,required=true )  @Valid @RequestBody DeleteConsentRequest deleteConsentRequest) {
        return getDelegate().deleteConsent(acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, deleteConsentRequest);
    }


    @ApiOperation(value = "Get detailed information about user payment account", nickname = "getAccount", notes = "User identification based on access token", response = AccountResponse.class, authorizations = {
        @Authorization(value = "xs2a_auth_aspsp", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            }),
        @Authorization(value = "xs2a_auth_decoupled", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            })
    }, tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = AccountResponse.class),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 429, message = "Request limit for the requested service exceeded", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/getAccount",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<AccountResponse> getAccount(@ApiParam(value = "The value of the Authorization header should consist of 'type' + 'credentials', where for the approach using the 'type' token should be 'Bearer'." ,required=true) @RequestHeader(value="Authorization", required=true) String authorization,@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for Account Request" ,required=true )  @Valid @RequestBody AccountInfoRequest getAccountRequest) {
        return getDelegate().getAccount(authorization, acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, getAccountRequest);
    }


    @ApiOperation(value = "Get information about all user's payment account", nickname = "getAccounts", notes = "User identification based on access token", response = AccountsResponse.class, authorizations = {
        @Authorization(value = "xs2a_auth_aspsp", scopes = {
            @AuthorizationScope(scope = "ais-accounts", description = "Permission to retrieve the list of accounts through Account Information Service")
            }),
        @Authorization(value = "xs2a_auth_decoupled", scopes = {
            @AuthorizationScope(scope = "ais-accounts", description = "Permission to retrieve the list of accounts through Account Information Service")
            })
    }, tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = AccountsResponse.class),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 429, message = "Request limit for the requested service exceeded", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/getAccounts",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<AccountsResponse> getAccounts(@ApiParam(value = "The value of the Authorization header should consist of 'type' + 'credentials', where for the approach using the 'type' token should be 'Bearer'." ,required=true) @RequestHeader(value="Authorization", required=true) String authorization,@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for Accounts Request" ,required=true )  @Valid @RequestBody AccountsRequest getAccountsRequest) {
        return getDelegate().getAccounts(authorization, acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, getAccountsRequest);
    }


    @ApiOperation(value = "Get list of user's holded operations", nickname = "getHolds", notes = "", response = HoldInfoResponse.class, authorizations = {
        @Authorization(value = "xs2a_auth_aspsp", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            }),
        @Authorization(value = "xs2a_auth_decoupled", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            })
    }, tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = HoldInfoResponse.class),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 429, message = "Request limit for the requested service exceeded", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/getHolds",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<HoldInfoResponse> getHolds(@ApiParam(value = "The value of the Authorization header should consist of 'type' + 'credentials', where for the approach using the 'type' token should be 'Bearer'." ,required=true) @RequestHeader(value="Authorization", required=true) String authorization,@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for hold Request" ,required=true )  @Valid @RequestBody HoldRequest getHoldsRequest) {
        return getDelegate().getHolds(authorization, acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, getHoldsRequest);
    }


    @ApiOperation(value = "Get detailed information about user's single transaction", nickname = "getTransactionDetail", notes = "", response = TransactionDetailResponse.class, authorizations = {
        @Authorization(value = "xs2a_auth_aspsp", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            }),
        @Authorization(value = "xs2a_auth_decoupled", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            })
    }, tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = TransactionDetailResponse.class),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 429, message = "Request limit for the requested service exceeded", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/getTransactionDetail",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<TransactionDetailResponse> getTransactionDetail(@ApiParam(value = "The value of the Authorization header should consist of 'type' + 'credentials', where for the approach using the 'type' token should be 'Bearer'." ,required=true) @RequestHeader(value="Authorization", required=true) String authorization,@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for transation detail Request" ,required=true )  @Valid @RequestBody TransactionDetailRequest getTransationDetailRequest) {
        return getDelegate().getTransactionDetail(authorization, acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, getTransationDetailRequest);
    }


    @ApiOperation(value = "Get list of user cancelled transactions", nickname = "getTransactionsCancelled", notes = "", response = TransactionsCancelledInfoResponse.class, authorizations = {
        @Authorization(value = "xs2a_auth_aspsp", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            }),
        @Authorization(value = "xs2a_auth_decoupled", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            })
    }, tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = TransactionsCancelledInfoResponse.class),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 429, message = "Request limit for the requested service exceeded", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/getTransactionsCancelled",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<TransactionsCancelledInfoResponse> getTransactionsCancelled(@ApiParam(value = "The value of the Authorization header should consist of 'type' + 'credentials', where for the approach using the 'type' token should be 'Bearer'." ,required=true) @RequestHeader(value="Authorization", required=true) String authorization,@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for Transactions Cancelled Request" ,required=true )  @Valid @RequestBody TransactionInfoRequest getTransactionsCancelledRequest) {
        return getDelegate().getTransactionsCancelled(authorization, acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, getTransactionsCancelledRequest);
    }


    @ApiOperation(value = "Get list of user done transactions", nickname = "getTransactionsDone", notes = "", response = TransactionsDoneInfoResponse.class, authorizations = {
        @Authorization(value = "xs2a_auth_aspsp", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            }),
        @Authorization(value = "xs2a_auth_decoupled", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            })
    }, tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = TransactionsDoneInfoResponse.class),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 429, message = "Request limit for the requested service exceeded", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/getTransactionsDone",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<TransactionsDoneInfoResponse> getTransactionsDone(@ApiParam(value = "The value of the Authorization header should consist of 'type' + 'credentials', where for the approach using the 'type' token should be 'Bearer'." ,required=true) @RequestHeader(value="Authorization", required=true) String authorization,@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for Transactions Done Request" ,required=true )  @Valid @RequestBody TransactionInfoRequest getTransactionsDoneRequest) {
        return getDelegate().getTransactionsDone(authorization, acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, getTransactionsDoneRequest);
    }


    @ApiOperation(value = "Get list of user's pending transactions", nickname = "getTransactionsPending", notes = "", response = TransactionPendingInfoResponse.class, authorizations = {
        @Authorization(value = "xs2a_auth_aspsp", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            }),
        @Authorization(value = "xs2a_auth_decoupled", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            })
    }, tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = TransactionPendingInfoResponse.class),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 429, message = "Request limit for the requested service exceeded", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/getTransactionsPending",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<TransactionPendingInfoResponse> getTransactionsPending(@ApiParam(value = "The value of the Authorization header should consist of 'type' + 'credentials', where for the approach using the 'type' token should be 'Bearer'." ,required=true) @RequestHeader(value="Authorization", required=true) String authorization,@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for Transactions Pending Request" ,required=true )  @Valid @RequestBody TransactionInfoRequest getTransactionsPendingRequest) {
        return getDelegate().getTransactionsPending(authorization, acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, getTransactionsPendingRequest);
    }


    @ApiOperation(value = "Get list of user's rejected transactions", nickname = "getTransactionsRejected", notes = "", response = TransactionRejectedInfoResponse.class, authorizations = {
        @Authorization(value = "xs2a_auth_aspsp", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            }),
        @Authorization(value = "xs2a_auth_decoupled", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            })
    }, tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = TransactionRejectedInfoResponse.class),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 429, message = "Request limit for the requested service exceeded", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/getTransactionsRejected",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<TransactionRejectedInfoResponse> getTransactionsRejected(@ApiParam(value = "The value of the Authorization header should consist of 'type' + 'credentials', where for the approach using the 'type' token should be 'Bearer'." ,required=true) @RequestHeader(value="Authorization", required=true) String authorization,@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for Transactions Rejected Request" ,required=true )  @Valid @RequestBody TransactionInfoRequest getTransactionsRejectedRequest) {
        return getDelegate().getTransactionsRejected(authorization, acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, getTransactionsRejectedRequest);
    }


    @ApiOperation(value = "Get list of user scheduled transactions", nickname = "getTransactionsScheduled", notes = "", response = TransactionsScheduledInfoResponse.class, authorizations = {
        @Authorization(value = "xs2a_auth_aspsp", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            }),
        @Authorization(value = "xs2a_auth_decoupled", scopes = {
            @AuthorizationScope(scope = "ais", description = "Permission to execute methods of Account Information Service in context of particular account")
            })
    }, tags={ "AIS", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success", response = TransactionsScheduledInfoResponse.class),
        @ApiResponse(code = 400, message = "Bad request", response = Error.class),
        @ApiResponse(code = 401, message = "Unauthorized", response = Error.class),
        @ApiResponse(code = 403, message = "Forbidden", response = Error.class),
        @ApiResponse(code = 405, message = "Method Not Allowed", response = Error.class),
        @ApiResponse(code = 406, message = "Not Acceptable", response = Error.class),
        @ApiResponse(code = 415, message = "Unsupported Media Type", response = Error.class),
        @ApiResponse(code = 422, message = "Unprocessable entity", response = Error.class),
        @ApiResponse(code = 429, message = "Request limit for the requested service exceeded", response = Error.class),
        @ApiResponse(code = 500, message = "Internal Server Error", response = Error.class),
        @ApiResponse(code = 501, message = "Not Implemented", response = Error.class),
        @ApiResponse(code = 503, message = "Service Unavailable", response = Error.class) })
    @RequestMapping(value = "/v2_1_2.1/accounts/v2_1_2.1/getTransactionsScheduled",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    default ResponseEntity<TransactionsScheduledInfoResponse> getTransactionsScheduled(@ApiParam(value = "The value of the Authorization header should consist of 'type' + 'credentials', where for the approach using the 'type' token should be 'Bearer'." ,required=true) @RequestHeader(value="Authorization", required=true) String authorization,@ApiParam(value = "Gzip, deflate" ,required=true, allowableValues="gzip, deflate") @RequestHeader(value="Accept-Encoding", required=true) String acceptEncoding,@ApiParam(value = "Prefered language of response" ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage,@ApiParam(value = "UTF-8" ,required=true, allowableValues="utf-8") @RequestHeader(value="Accept-Charset", required=true) String acceptCharset,@ApiParam(value = "Detached JWS signature of the body of the payload" ,required=true) @RequestHeader(value="X-JWS-SIGNATURE", required=true) String X_JWS_SIGNATURE,@ApiParam(value = "Identyfikator żądania w formacie UUID (Wariant 1, Wersja 1), zgodnym ze standardem RFC 4122, nadawany przez TPP. Wartość musi być zgodna z parametrem requestId przekazywanym w ciele każdego żądania. / Request identifier using UUID format (Variant 1, Version 1), described in RFC 4122 standard, set by TPP. Value of this header must be the same as for the requestId param passed inside request payload." ,required=true) @RequestHeader(value="X-REQUEST-ID", required=true) String X_REQUEST_ID,@ApiParam(value = "Data for Transactions Scheduled Request" ,required=true )  @Valid @RequestBody TransactionInfoRequest getTransactionsScheduledRequest) {
        return getDelegate().getTransactionsScheduled(authorization, acceptEncoding, acceptLanguage, acceptCharset, X_JWS_SIGNATURE, X_REQUEST_ID, getTransactionsScheduledRequest);
    }

}
